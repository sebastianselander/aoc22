module Matrix where

import Data.Vector (Vector, MVector)
import Data.Vector qualified as V
import Data.Vector.Mutable qualified as MV

type Row = Int
type Col = Int
data Matrix a = Matrix { getVec :: (Vector a)
                       , height :: Int
                       , width :: Int
                       }

instance Foldable Matrix where
  foldr f acc m@(Matrix _ _ _) = foldr f acc (getVec m)

instance Show a => Show (Matrix a) where
    show m@(Matrix vec w h) = show $ map (flip unsafeRow m) [0 .. h - 1]

-- prettyPrint :: Show a => Matrix a -> IO ()
prettyPrint m@(Matrix vec h w) = mapM_ (putStrLn . show ) $ map (flip unsafeRow m) [0 .. h - 1]

null :: Matrix a -> Bool
null (Matrix vec w h) = V.null vec

size :: Matrix a -> Int
size m = width m * height m

initAll :: a -> Row -> Col -> Matrix a
initAll v w h = Matrix (V.replicate (w * h) v) w h

unsafeGet :: Row -> Col -> Matrix a -> a
unsafeGet x y m@( Matrix vec w h )
  | x < 0     = error $ "Row: " <> show x <> " does not exist"
  | y < 0     = error $ "Col: " <> show y <> " does not exist"
  | x * h + y * w >= size m = error "Index out of range"
  | otherwise = vec V.! (x * h + y * w)

get :: Int -> Int -> Matrix a -> Maybe a
get x y m@( Matrix vec w h ) = vec V.!? (x * h + y * w)

unsafeRow :: Int -> Matrix a -> Vector a
unsafeRow index (Matrix vec h w)
  | index >= h = error $ "Row index: " <> show h <> " out of range"
  | otherwise  = V.slice (index * h) w vec

row :: Int -> Matrix a -> Maybe (Vector a)
row index (Matrix vec _ _) = undefined
